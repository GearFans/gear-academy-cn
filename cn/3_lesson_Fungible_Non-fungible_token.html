<html lang="zh-CN" class="translated-ltr"><head>
  <base href="https://108.ufo.k0s.io/3_lesson_Fungible_Non-fungible_token.md"> 
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      document.title = window.location.hostname;
    });
  </script> 
  <meta charset="UTF-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <style>
    body {
      font-family: "Arial", sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }

    h1 {
      font-size: 2rem;
      color: #222;
      margin-bottom: 10px;
    }

    h1 a {
      color: #222;
      text-decoration: none;
    }

    a {
      color: #2a7ae2;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    p {
      margin-bottom: 20px;
    }

    hr {
      border: 0;
      border-top: 1px solid #eee;
      margin: 20px 0;
    }

    table {
      border-collapse: collapse;
      width: 50%;
    }

    th, td {
      border: 1px solid black;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f2f2f2;
    }
  </style> 
  <meta http-equiv="X-Translated-By" content="Google">
  <meta http-equiv="X-Translated-To" content="zh-CN">
  <script type="text/javascript" src="https://www.gstatic.com/_/translate_http/_/js/k=translate_http.tr.en_US.WYPRFnOi8do.O/d=1/rs=AN8SPfpuhFJPZIC1bAeelVoE7UV7Vt-MPA/m=corsproxy" data-sourceurl="https://108.ufo.k0s.io/3_lesson_Fungible_Non-fungible_token.md" data-navigation-history-proxy-enabled="true"></script>
  <meta name="robots" content="none">
 <script async="" src="https://www.gstatic.com/feedback/js/help/prod/service/lazy.min.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://www.gstatic.com/_/translate_http/_/ss/k=translate_http.tr.69JJaQ5G5xA.L.W.O/d=0/rs=AN8SPfpC36MIoWPngdVwZ4RUzeJYZaC7rg/m=el_main_css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/_/translate_http/_/js/k=translate_http.tr.zh_CN.vP9ARk0hD0A.O/d=1/exm=el_conf/ed=1/rs=AN8SPfr7Qhi-OTQKbFnpEq_vjdvjiKNGqA/m=el_main"></script><title>108-飞碟-k0s-io.translate.goog</title></head> 
 <body style="margin-top: 56px;">
  <script type="text/javascript" src="https://www.gstatic.com/_/translate_http/_/js/k=translate_http.tr.en_US.WYPRFnOi8do.O/d=1/exm=corsproxy/ed=1/rs=AN8SPfpuhFJPZIC1bAeelVoE7UV7Vt-MPA/m=navigationui" data-environment="prod" data-proxy-url="https://108-ufo-k0s-io.translate.goog" data-proxy-full-url="https://108-ufo-k0s-io.translate.goog/3_lesson_Fungible_Non-fungible_token.md?_x_tr_sl=en&amp;_x_tr_tl=zh-CN&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=wapp" data-source-url="https://108.ufo.k0s.io/3_lesson_Fungible_Non-fungible_token.md" data-source-language="en" data-target-language="zh-CN" data-display-language="zh-CN" data-detected-source-language="" data-is-source-untranslated="false" data-source-untranslated-url="https://translate.google.com/website?sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;client=webapp&amp;u=https://108.ufo.k0s.io/3_lesson_Fungible_Non-fungible_token.md&amp;anno=2" data-use-in-place-translation="true" data-client="webapp"></script> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第 3 课：了解可替代/不可替代的代币</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">课程总结</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本课介绍加密令牌的概念</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们解释了同质化和非同质化代币 (NFT) 及其主要功能</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font class="" style="vertical-align: inherit;">我们还解释了可替代和不可替代代币 (NFT) 之间的区别</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强调了理解这些密码学概念的重要性，尤其是在创建程序方面</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">课程目标</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在课程结束时，您将：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义加密令牌并将它们与其他类型的令牌区分开来</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区分可替代和不可替代的代币并解释它们各自的用例</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用他们的加密代币知识，使用可替代和不可替代的代币创建程序</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解如何在 Gear 协议中实施可替代和不可替代的代币</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们开始吧！</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可替代令牌及其属性</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可替代代币提供与法定货币相同的价值和可兑换性。</font><font style="vertical-align: inherit;">就像将一张纸币换成另一张纸币一样，这些数字智能合约允许用户在账户之间交易等值的代币化资产。</font><font style="vertical-align: inherit;">然而，在基础技术层面上，可替代代币只是存储账户地址和代币数量之间映射的智能合约。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">аaddress [图像占位符] 数量</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类智能合约的主要功能是：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfer(from, to, amount)：此功能允许您将代币数量（金额）从一个地址（from）转移到另一个地址（to）。</font><font style="vertical-align: inherit;">它检查“from”账户是否拥有代币，从其余额中减去必要的金额，并将指定的代币数量添加到“to”账户。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approve(spender, amount) 是一个函数，它允许您授予指定的支出者账户处置调用此函数的账户的代币的权利（在我们的例子中，它将是 msg::source()）。</font><font style="vertical-align: inherit;">换句话说，spender账户可以调用transfer()函数，所以它可以将token从msg::source()账户转移到指定地址。</font><font style="vertical-align: inherit;">当在任何合约中发生代币转移时，此功能很有用。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们以托管智能合约为例。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这个例子中，货物是使用代币支付的，而不是 msg::value()。</font><font style="vertical-align: inherit;">买方发送 deposit() 消息，托管智能合约访问代币合约并发送代币转移消息。</font><font style="vertical-align: inherit;">在此特定消息中，发件人地址是买家地址。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果托管合约无权处置买方的代币，那么代币合约就会恐慌并阻止代币转移。</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mint(to, amount)：这个函数增加了合约中的代币数量。</font><font style="vertical-align: inherit;">通常，此函数可以由允许创建新令牌的某些帐户调用。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Burn(from, amount) 是一个减少合约中代币数量的函数。</font><font style="vertical-align: inherit;">就像 mint() 函数一样，并非所有帐户都可以销毁代币。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可替代的代币</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可替代的代币或 NFT 提供了一种独特的方式来证明数字资产的所有权。</font><font style="vertical-align: inherit;">虽然传统的可替代代币可以互换并存储价值，但 NFT 带有加密证书，证明所有者对数字艺术或游戏资产等资产的权威。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址[图片占位符]token_id</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类代币合约的主要功能类似于同质化代币：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfer(to, token_id) 是一个函数，允许您将带有 token_id 编号的令牌转移到 to 帐户。</font><font style="vertical-align: inherit;">与可替代代币合约不同，该合约不需要来自账户，因为每个代币都有自己的所有者。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approve(approved_account, token_id) 是一个函数，允许您将处理令牌的权利授予指定的 approved_account。</font><font style="vertical-align: inherit;">此功能可用于拍卖市场。</font><font style="vertical-align: inherit;">当所有者想要出售他的代币时，他们可以将其放在市场/拍卖中，因此合约会将此代币发送给新所有者。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mint(to, token_id, metadata) 是一个创建新令牌的函数。</font><font style="vertical-align: inherit;">元数据可以包括关于令牌的任何信息：它可以是特定资源的链接、令牌的描述等。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Burn(from, token_id)：此函数从合约中删除具有上述 token_id 的代币。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序间的异步通信</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gear 协议的关键和显着特征之一是用于消息传递通信的 Actor 模型。</font><font style="vertical-align: inherit;">Gear Protocol 利用 Actor 模型进行消息传递通信，允许并行计算和异步消息传递以确保更快的处理时间。</font><font style="vertical-align: inherit;">开发结构在构建复杂的 dApp 时为开发人员提供了巨大的灵活性。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果一个程序向另一个程序发送异步消息，它需要等待那个程序的回复才能进行下一个操作。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要向 Gear 程序发送消息，我们使用 send_for_reply(program, payload, value) 函数。</font><font style="vertical-align: inherit;">在这个函数中：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">program - 要为其发送消息的程序的地址；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">payload - 给程序的消息；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value - 附加到消息的资金。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分布式事务</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gear 协议中程序之间的交互创建分布式事务，涉及具有各自状态的参与者之间的操作。</font><font style="vertical-align: inherit;">在我们的例子中，操作是在具有状态的参与者之间执行的。</font><font style="vertical-align: inherit;">分布式事务必须具备以下特性：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原子性：所有数据更改都被视为单个操作。</font><font style="vertical-align: inherit;">也就是说，要么进行所有修改，要么不进行任何修改。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一致性：这个属性意味着当一个事务开始和结束时，数据的状态是一致的。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，在以太坊交易中，全局状态更改仅在所有执行成功完成时发生。</font><font style="vertical-align: inherit;">如果在执行期间发生错误，对状态的所有更改都将“回滚”，就好像事务从未运行过一样。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看下面的代码：</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在提供的示例代码中，全局变量 COUNTER 在调用 send_for_reply 函数之前设置为 10。</font><font style="vertical-align: inherit;">如果事务在.await之前失败，则状态回滚，COUNTER归0。如果事务在.await之后失败，COUNTER的值保持为10。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们考虑一个简单的市场示例，其中代币被转移给卖家，然后将 NFT 转移给买家。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[图像占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图片显示了以下情况：</font></font></p> 
  <ol> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">市场成功将代币转移给卖家；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NFT 转给买方过程中，交易失败。</font></font></p> </li> 
  </ol> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代币转移成功后，NFT 从卖方转移到买方的过程中的交易失败将导致不一致的状态，即卖方收到付款但买方没有收到 NFT。</font><font style="vertical-align: inherit;">因此，在开发应用程序和不同标准时，我们必须考虑导致状态不一致的潜在故障。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在 Gear 上实施可替代代币</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们建议将可替代代币拆分为三个合约：</font></font></p> 
  <ol> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为代理程序的主同质代币，将消息重定向到逻辑合约。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代币逻辑合约——负责实现主要的标准代币功能。</font><font style="vertical-align: inherit;">我们将逻辑放在一个单独的合约中，以在不丢失可替代代币地址和合约状态的情况下添加更多功能。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储合约：这些合约存储用户的余额。</font></font></p> </li> 
  </ol> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[图像占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌标准有一个防止重复交易（保持幂等性）的特性：发送交易时有两种可能的风险：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送重复交易</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于网络故障而不知道交易状态。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送方可以放心，交易只会执行一次（幂等性）。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储合约架构</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储合同状态有以下字段：</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约的地址。</font><font style="vertical-align: inherit;">存储合约必须执行仅从该地址接收的消息；</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已执行的交易。</font><font style="vertical-align: inherit;">在每条消息中，存储合约接收正在执行的交易的哈希值，并将其执行结果存储在字段 Executed 中。</font><font style="vertical-align: inherit;">如果 Executed 为 true，则消息执行成功，否则 Executed 等于 false。</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">账户余额</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">核准帐目</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储接受的消息：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加余额：存储增加指定账户的余额；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减少余额：存储减少指定账户的余额；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">批准：存储允许账户授予另一个账户转移其代币的权限；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转账：将代币从一个账户转移到另一个账户。</font><font style="vertical-align: inherit;">当令牌传输发生在一个存储中时，从逻辑合约调用消息。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清除：删除已执行交易的哈希。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该存储合约不进行任何异步调用，因此它的执行是原子的。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约架构</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约的状态由以下字段组成：</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主代币合约地址。</font><font style="vertical-align: inherit;">逻辑合约必须只执行来自该地址的消息：</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交易。</font><font style="vertical-align: inherit;">与存储合约一样，逻辑合约接收正在执行的交易的哈希值并存储其执行结果。</font><font style="vertical-align: inherit;">但与消息执行是原子的存储合约不同，逻辑合约必须跟踪正在执行的消息及其阶段。</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事务是以下结构：</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中 msg_source 是一个向主合约发送消息的账户。</font><font style="vertical-align: inherit;">Operation是逻辑合约应该处理的动作，status是交易状态。</font><font style="vertical-align: inherit;">它是以下枚举。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InProgress - 事务执行开始；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功或失败 - 交易已完成（成功或不成功）。</font><font style="vertical-align: inherit;">在这种情况下，逻辑合约只发送一个响应，表明这个哈希值的交易已经完成。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储合约的代码哈希。</font><font style="vertical-align: inherit;">逻辑合约能够在必要时创建新的存储合约。</font><font style="vertical-align: inherit;">存储创建实现如下：</font></font></p> 
    <ul> 
     <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约取账户地址的首字母。</font><font style="vertical-align: inherit;">如果创建了这封信的存储合约，那么它将这个账户的余额存储在这个合约中。</font><font style="vertical-align: inherit;">如果不是，它会创建一个新的存储合约</font></font></li> 
    </ul> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从字母到存储地址的映射。</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约从主合约接收到以下消息：</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该帐户是向主合约发送消息的参与者。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效负载是逻辑合约必须处理的编码操作：</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">升级逻辑合约时，枚举操作可能会发生变化，这意味着负载结构也可能会发生变化。</font><font style="vertical-align: inherit;">因此，主合约不知道负载结构的具体类型，而是将其作为字节数组发送（Vec</font></font><u8><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    ).
   </font></font></u8></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约在同一存储中账户之间的 Mint、Burn 或 Transfer 消息期间只向存储合约发送一条消息。</font><font style="vertical-align: inherit;">收到消息后，逻辑合约将有效负载从字节数组解码为预期的枚举操作。</font><font style="vertical-align: inherit;">这允许逻辑合约根据特定操作类型（Mint、Burn 或 Transfer）处理消息</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[图像占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当传输发生在 2 个不同的存储之间时，合约的行为如下：</font></font></p> 
  <ol> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约将 DecreaseBalance 消息发送到存储合约。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果消息执行成功，则逻辑合约将消息 IncreaseBalance 发送到另一个存储合约。</font><font style="vertical-align: inherit;">否则，逻辑合约保存失败状态并回复主合约。</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果消息 IncreaseBalance 执行成功，则逻辑合约保存状态并回复主合约。</font><font style="vertical-align: inherit;">如果在存储合约中执行 IncreaseBalance 期间 gas 用完，则逻辑合约将状态保存为 DecreaseSuccess。</font><font style="vertical-align: inherit;">这个状态在 handle_signal 函数中是不可追踪的。</font></font></p> </li> 
  </ol> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果交易执行不成功，则可能是由于合约内存出现问题。</font><font style="vertical-align: inherit;">逻辑合约必须跟踪存储合约并重新运行任何失败的交易以防止失败。</font><font style="vertical-align: inherit;">如果错误仍然存​​在，则应退还余额。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主合约架构</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主合约的状态包括以下字段：</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合约管理员的地址。</font><font style="vertical-align: inherit;">他有升级逻辑合约的权利。</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑合约的地址</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <ul> 
   <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交易历史。</font></font></li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中 TransactionStatus:[Image Placeholder]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合约从具有特定随机数的帐户接收消息，该随机数用于计算交易哈希以及帐户地址。</font><font style="vertical-align: inherit;">用户有责任跟踪他们的随机数并在每次后续交易中增加它。</font><font style="vertical-align: inherit;">但是，可以以自动跟踪用户随机数的方式设计合约，使随机数字段成为可选的。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主合约只是将该消息重定向到逻辑合约，指示向其发送消息的帐户。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此作业中，您将向您的 Tamagotchi 智能合约添加功能，以允许更改所有权并批准其他帐户更改所有权。</font><font style="vertical-align: inherit;">这将涉及实现以下功能：</font></font></p> 
  <ul> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfer(new_owner) - 该操作必须将字段所有者更改为指定的帐户；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approve(allowed_account) - 该操作必须填写指定帐户的 approved_account 字段；</font></font></p> </li> 
   <li><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RevokeApproval - 该操作删除当前的 approved_account。</font></font></p> </li> 
  </ul> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将您的合约上传到区块链，运行前端应用程序并选择第三课。</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为确保您的合约与前端应用程序兼容，请确保将元数据设置为以下内容：</font></font></p> 
  <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[代码占位符]</font></font></p>  
  <script>function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('en', 'zh-CN', function () {});}</script>
  <script src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;hl=zh-CN&amp;client=wt" type="text/javascript"></script><div id="goog-gt-" class="VIpgJd-suEOdc VIpgJd-yAWNEb-L7lbkb skiptranslate" dir="ltr" style="visibility: hidden; left: 255px; top: 4644px; display: none;"><div style="padding: 8px;"><div><div class="VIpgJd-yAWNEb-l4eHX"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google 翻译"></div></div></div><div style="padding: 8px; float: left; width: 100%;"><h1 class="VIpgJd-yAWNEb-r4nke VIpgJd-yAWNEb-mrxPge">原文</h1></div><div style="padding: 8px;"><div class="VIpgJd-yAWNEb-nVMfcd-fmcmS">We also explain the difference between fungible and non-fungible tokens (NFTs)</div></div><div class="VIpgJd-yAWNEb-cGMI2b" style="padding: 8px;"><div class="VIpgJd-yAWNEb-Z0Arqf-PLDbbf"><span class="VIpgJd-yAWNEb-Z0Arqf-hSRGPd">提供更好的翻译建议</span></div><div class="VIpgJd-yAWNEb-fw42Ze-Z0Arqf-haAclf"><hr style="color: #ccc; background-color: #ccc; height: 1px; border: none;"><div class="VIpgJd-yAWNEb-Z0Arqf-H9tDt"></div></div></div><div class="VIpgJd-yAWNEb-jOfkMb-Ne3sFf" style="display: none; opacity: 0;"></div></div>
 
</body></html>
